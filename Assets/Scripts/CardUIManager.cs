using System.Collections; using System.Collections.Generic; using System.Linq; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.SceneManagement; using UnityEngine.UI;  public class CardUIManager : MonoBehaviour {     [Header("UI References")]     public GameObject cardPrefab;          // 卡牌预制体     public Transform handContainer;        // 手牌容器          [Header("Game Settings")]     public int useCardNum = 3;             // 每回合可使用的手牌数量     private int curUseCardNum = 0;         // 当前回合已使用的手牌数          // 单例实例     public static CardUIManager Instance;          // 拖拽相关变量     private GameObject draggedCard;        // 当前被拖拽的卡牌对象     private CardData draggedCardData;      // 当前被拖拽的卡牌数据     private Canvas canvas;                 // UI画布          // 选择状态     private bool isSelectingMoveTarget;    // 是否处于移动目标选择状态     private bool isSelectShockTarget;      // 是否处于冲击波方向选择状态     private bool isSelectTeleportTarget;   // 是否处于传送门选择状态       // 在CardUIManager类中添加以下变量     [Header("特效设置")]     public float shockwaveSpeed = 5f; // 冲击波行进速度     public float effectDelay = 0.2f; // 每个地块销毁特效的间隔时间     private void Awake()
    {
        // 单例初始化
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }

        canvas = GetComponentInParent<Canvas>();
    }

    private void Start()
    {
        // 在 Start 中初始化，确保其他组件已准备好
        if (TurnManager.Instance != null && TurnManager.Instance.onTurnStarted != null)
        {
            TurnManager.Instance.onTurnStarted.AddListener(OnTurnStarted);
        }
        else
        {
            Debug.LogError("TurnManager 或其事件未初始化！");
        }
    }
    /// <summary>     /// 更新手牌UI显示     /// </summary>     /// <param name="hand">当前手牌数据列表</param>     public void UpdateHandUI(List<CardData> hand)     {         Debug.Log($"更新手牌UI，手牌数量: {hand?.Count}");          // 清空现有手牌         foreach (Transform child in handContainer)         {             Destroy(child.gameObject);         }          if (hand == null || hand.Count == 0)         {             Debug.LogWarning("手牌数据为空！");             return;         }          // 创建新手牌UI         foreach (var card in hand)         {             Debug.Log($"创建卡牌:{card?.type}");             CreateCardUI(card);         }     }      /// <summary>     /// 回合开始时重置使用卡牌计数     /// </summary>     void OnTurnStarted()     {         curUseCardNum = 0;     }      /// <summary>     /// 创建单个卡牌UI     /// </summary>     /// <param name="card">卡牌数据</param>     private void CreateCardUI(CardData card)     {         GameObject cardObj = Instantiate(cardPrefab, handContainer);         cardObj.GetComponent<Image>().sprite = card.icon;          // 设置卡牌数据         var display = cardObj.GetComponent<CardDisplay>();         if (display != null)         {             Debug.Log($"创建卡牌UI: {card.type}");             display.SetCardData(card);         }                  // 添加拖拽事件         AddDragEvents(cardObj);     }      /// <summary>     /// 为卡牌添加拖拽事件     /// </summary>     /// <param name="cardObj">卡牌游戏对象</param>     private void AddDragEvents(GameObject cardObj)     {         Debug.Log($"正在为{cardObj.name} 添加拖拽事件");                  EventTrigger trigger = cardObj.GetComponent<EventTrigger>() ?? cardObj.AddComponent<EventTrigger>();                  if (trigger == null)         {             Debug.LogError("EventTrigger 添加失败！");             return;         }          // 开始拖拽事件         EventTrigger.Entry beginDrag = new EventTrigger.Entry();         beginDrag.eventID = EventTriggerType.BeginDrag;         beginDrag.callback.AddListener((data) => OnBeginDrag(cardObj, (PointerEventData)data));         trigger.triggers.Add(beginDrag);          // 拖拽中事件         EventTrigger.Entry drag = new EventTrigger.Entry();         drag.eventID = EventTriggerType.Drag;         drag.callback.AddListener((data) => OnDrag((PointerEventData)data));         trigger.triggers.Add(drag);          // 结束拖拽事件         EventTrigger.Entry endDrag = new EventTrigger.Entry();         endDrag.eventID = EventTriggerType.EndDrag;         endDrag.callback.AddListener((data) => OnEndDrag((PointerEventData)data));         trigger.triggers.Add(endDrag);     }      /// <summary>     /// 开始拖拽卡牌     /// </summary>     private void OnBeginDrag(GameObject card, PointerEventData eventData)     {         var display = card.GetComponent<CardDisplay>();         if (display != null)         {             display.SetDraggingStatus(true);         }          // 获取卡牌数据         draggedCardData = display?.cardData;         if (draggedCardData == null)         {             Debug.LogError("拖拽卡牌数据丢失！");             return;         }          // 创建拖拽副本         draggedCard = Instantiate(card, canvas.transform);         draggedCard.transform.SetAsLastSibling();          var img = draggedCard.GetComponent<Image>();         img.raycastTarget = false;         img.color = new Color(1, 1, 1, 0.7f);     }      /// <summary>     /// 拖拽卡牌中     /// </summary>     private void OnDrag(PointerEventData eventData)     {         if (draggedCard != null)         {             draggedCard.transform.position = eventData.position;         }     }      /// <summary>     /// 结束拖拽卡牌     /// </summary>     private void OnEndDrag(PointerEventData eventData)     {         if (draggedCard == null) return;                  // 恢复原始卡牌状态         var originalCard = eventData.pointerDrag;         if (originalCard != null)         {             var display = originalCard.GetComponent<CardDisplay>();             if (display != null)             {                 display.SetDraggingStatus(false);             }         }          Destroy(draggedCard);          // 检查是否可以出牌         if (!IsUseCard()) return;          // 检查使用卡牌数量限制         if (useCardNum > curUseCardNum)         {             curUseCardNum++;         }         else         {             Debug.Log($"使用手牌数已达到{useCardNum}，自动结束回合");             TurnManager.Instance.EndPlayerTurn();             return;         }          // 检查是否在可出牌区域         if (IsOverPlayArea(eventData) && draggedCardData != null)         {             // 使用卡牌             bool success = CardManager.Instance.PlayCard(draggedCardData);             if (!success)             {                 Debug.LogError("卡牌使用失败！");                 return;             }             Debug.Log("使用手牌的类型："+ draggedCardData.type);              // 根据卡牌类型执行不同操作             switch (draggedCardData.type)             {                 case CardData.CardType.Move:                     StartMoveTargetSelection();                     break;                 case CardData.CardType.Shock:                     StartShockDirectionSelection();                     break;                 case CardData.CardType.Replenish:                     CardManager.Instance.AddCard(3);                     break;                 case CardData.CardType.EnergyStone:                     BlockPillarSystem.Instance.UseEnergyStone();                     break;                 case CardData.CardType.Teleport:                     StartTeleportSelection();                     break;                 default:                     draggedCardData = null;                     break;             }         }         else         {             draggedCardData = null;         }     }      /// <summary>     /// 判断是否可以出牌     /// </summary>     bool IsUseCard()     {         if (draggedCardData.type == CardData.CardType.EnergyStone && BlockPillarSystem.Instance.isUseEnergyStone)         {             Debug.Log("能量石次数没用完，不能使用新的能量石");             return false;         }                  if (isSelectingMoveTarget)         {             Debug.Log("正在移动选择中，不可使用卡牌");             return false;         }                  if (isSelectShockTarget)         {             Debug.Log("正在冲击波选择中，不可使用卡牌");             return false;         }                  if (isSelectTeleportTarget)         {             Debug.Log("正在选择传送门中，不可使用卡牌");             return false;         }          // 传送门卡牌特殊检查         if (draggedCardData.type == CardData.CardType.Teleport)         {             Vector3Int playerPos = HexGridSystem.Instance.WorldToCell(PlayerController.Instance.transform.position);             Vector3Int[] directions = HexGridSystem.Instance.GetNeighborDirectionsForPosition(playerPos);             bool isCreate = false;                          foreach (var dir in directions)             {                 Vector3Int neighborPos = playerPos + dir;                 if (HexGridSystem.Instance.IsNormalHexTile(neighborPos))                 {                     isCreate = true;                     break;                 }             }                          if (!isCreate)             {                 Debug.Log("玩家附近没有可生成传送门的地方");             }             return isCreate;         }          return true;     }      /// <summary>     /// 开始移动目标选择     /// </summary>     private void StartMoveTargetSelection()     {         isSelectingMoveTarget = true;         HexGridSystem.Instance.ClearAllHighlights();          if (HexGridSystem.Instance == null || PlayerController.Instance == null)         {             Debug.LogError("HexGridSystem或PlayerController实例未初始化！");             return;         }          // 获取玩家当前位置         Vector3Int playerHex = HexGridSystem.Instance.WorldToCell(PlayerController.Instance.transform.position);          if (!HexGridSystem.Instance.IsHexValid(playerHex))         {             Debug.LogError("玩家位置无效！");             return;         }          // 高亮可移动格子         var neighbors = HexGridSystem.Instance.GetWalkableNeighbors(playerHex);         foreach (var pos in neighbors)         {             HexGridSystem.Instance.HighlightHex(pos, true);         }          // 注册点击事件         TilemapClickHandler.OnHexClicked += HandleHexClick;     }      /// <summary>     /// 处理格子点击事件     /// </summary>     private void HandleHexClick(Vector3Int hexPosition)     {         Debug.Log($"点击高亮格子: {hexPosition} isSelectingMoveTarget:{isSelectingMoveTarget}");         if (!isSelectingMoveTarget)         {             Debug.LogWarning("当前不在选择移动目标状态！");             return;         }          if (draggedCardData == null)         {             Debug.LogError("卡牌数据丢失，无法执行移动！");             return;         }          Debug.Log("准备移动玩家...");         PlayerController.Instance.MoveToHex(hexPosition);         EndMoveTargetSelection();     }      /// <summary>     /// 结束移动目标选择     /// </summary>     public void EndMoveTargetSelection()     {         isSelectingMoveTarget = false;         HexGridSystem.Instance.ClearAllHighlights();         TilemapClickHandler.OnHexClicked -= HandleHexClick;         Debug.Log("已取消高亮并解除点击事件绑定");          draggedCardData = null;         Debug.Log("移动目标选择结束，卡牌数据已清除");     }      /// <summary>     /// 判断是否在出牌区域     /// </summary>     private bool IsOverPlayArea(PointerEventData eventData)     {         var results = new List<RaycastResult>();         EventSystem.current.RaycastAll(eventData, results);          foreach (var result in results)         {             if (result.gameObject.CompareTag("PlayArea"))             {                 return true;             }         }          return false;     }      /// <summary>     /// 开始冲击波方向选择     /// </summary>     private void StartShockDirectionSelection()     {         isSelectShockTarget = true;         HexGridSystem.Instance.ClearAllHighlights();         Vector3Int playerPos = HexGridSystem.Instance.WorldToCell(PlayerController.Instance.transform.position);          // 获取所有可能方向         Vector3Int[] directions = HexGridSystem.Instance.GetNeighborDirectionsForPosition(playerPos);          // 高亮所有可能方向的第一个格子         foreach (var dir in directions)         {             Vector3Int neighborPos = playerPos + dir;             if (HexGridSystem.Instance.IsHexValid(neighborPos))             {                 HexGridSystem.Instance.HighlightHex(neighborPos, true);             }         }                  TilemapClickHandler.OnHexClicked += HandleShockDirectionSelected;     }      /// <summary>     /// 处理冲击波方向选择     /// </summary>     private void HandleShockDirectionSelected(Vector3Int selectedPos)     {         if (HexGridSystem.Instance == null)         {             Debug.LogError("HexGridSystem 实例未找到！");             return;         }                  if (PlayerController.Instance == null)         {             Debug.LogError("PlayerController 实例未找到！");             return;         }                  if (draggedCardData == null)         {             Debug.LogError("卡牌数据丢失！");             return;         }          Vector3Int playerPos = HexGridSystem.Instance.WorldToCell(PlayerController.Instance.transform.position);         Vector3Int direction = selectedPos - playerPos;         Debug.Log("玩家位置：" + playerPos);         Debug.Log("选择的方向：" + direction);          // 获取该方向上的所有格子         List<Vector3Int> tilesToClear = HexGridSystem.Instance.GetTilesInDirection(             playerPos, direction, draggedCardData.maxClearDistance         );          EndShockSelection();          // 启动协程播放序列特效     StartCoroutine(PlayShockwaveEffects(playerPos, direction, tilesToClear));              }      // 新增协程方法 - 按顺序播放冲击波和销毁特效     private IEnumerator PlayShockwaveEffects(Vector3Int startCell, Vector3Int direction, List<Vector3Int> tilesToClear)     {         Vector3 startPos = HexGridSystem.Instance.GetHexCenterPosition(startCell);         Vector3 endPos = HexGridSystem.Instance.GetHexCenterPosition(startCell + direction * tilesToClear.Count);          // 播放主冲击波特效         EffectManager.Instance.PlayShockwaveEffect(startPos, endPos, 1f);          // 逐个处理地块         for (int i = 0; i < tilesToClear.Count; i++)         {             Vector3Int pos = tilesToClear[i];             Vector3 worldPos = HexGridSystem.Instance.GetHexCenterPosition(pos);              // 如果是黑雾地块则清除并播放特效             if (HexGridSystem.Instance.IsDarkHexTile(pos))             {                 // 播放销毁特效                 EffectManager.Instance.PlayTileDestroyEffect(worldPos);                  // 实际清除地块（延迟一点时间让特效更明显）                 yield return new WaitForSeconds(effectDelay);                 DarkTileSystem.Instance.ClearDarkTile(pos);             }             else             {                 yield return null;             }         }      }/// <summary>     /// 结束冲击波选择     /// </summary>          private void EndShockSelection()     {         HexGridSystem.Instance.ClearAllHighlights();         TilemapClickHandler.OnHexClicked -= HandleShockDirectionSelected;          draggedCardData = null;         Debug.Log("Shock方向选择结束，卡牌数据已清除");         isSelectShockTarget = false;     }      /// <summary>     /// 开始传送门选择     /// </summary>     private void StartTeleportSelection()     {         isSelectTeleportTarget = true;         HexGridSystem.Instance.ClearAllHighlights();         Vector3Int playerPos = HexGridSystem.Instance.WorldToCell(PlayerController.Instance.transform.position);                  TeleportSystem.Instance.CreateTeleport(playerPos, delegate()          {             isSelectTeleportTarget = false;         });     }      private void Update()     {         // 右键取消当前操作         if (draggedCard != null && Input.GetMouseButtonUp(1))         {             GameObject.Destroy(draggedCard);             draggedCard = null;         }          if (draggedCardData != null && Input.GetMouseButtonUp(1))         {             HexGridSystem.Instance.ClearAllHighlights();             var curCardsInHand = CardManager.Instance.CurrentHand;              // 根据不同卡牌类型取消操作             switch (draggedCardData.type)             {                 case CardData.CardType.Move:                     isSelectingMoveTarget = false;                     curCardsInHand.Add(CardManager.Instance.allCardTypes.Single(data => data.type == CardData.CardType.Move));                     break;                 case CardData.CardType.Shock:                     isSelectShockTarget = false;                     TilemapClickHandler.OnHexClicked -= HandleShockDirectionSelected;                     curCardsInHand.Add(CardManager.Instance.allCardTypes.Single(data => data.type == CardData.CardType.Shock));                     break;                 case CardData.CardType.Teleport:                     isSelectTeleportTarget = false;                     curCardsInHand.Add(CardManager.Instance.allCardTypes.Single(data => data.type == CardData.CardType.Teleport));                     TeleportSystem.Instance.ClearTeleport();                     break;             }              UpdateHandUI(curCardsInHand);             curUseCardNum--;             draggedCardData = null;         }     }
    // 在CardUIManager.cs中添加以下方法
    public void ClearAllEventListeners()
    {
        // 清除所有Tilemap点击事件
        TilemapClickHandler.OnHexClicked -= HandleHexClick;
        TilemapClickHandler.OnHexClicked -= HandleShockDirectionSelected;

        // 重置所有选择状态
        isSelectingMoveTarget = false;
        isSelectShockTarget = false;
        isSelectTeleportTarget = false;

        // 清除拖拽状态
        if (draggedCard != null)
        {
            Destroy(draggedCard);
            draggedCard = null;
        }
        draggedCardData = null;
    }

    // 添加场景加载处理
    private void OnEnable()
    {
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    private void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        // 重新初始化所有必要的引用
        ClearAllEventListeners();

        // 确保UI更新
        if (CardManager.Instance != null)
        {
            UpdateHandUI(CardManager.Instance.CurrentHand);
        }
    } }